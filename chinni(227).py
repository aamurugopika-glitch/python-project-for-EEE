# -*- coding: utf-8 -*-
"""chinni(227).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tgkOLHSpZykdXDlYO0OA7PZLVmFAHra4
"""

import numpy as np
from scipy.sparse.linalg import spsolve
import matplotlib.pyplot as plt

# Define bus types
SLACK = 0
PV = 1
PQ = 2

bus_data = np.array([
    [1, SLACK, 1.0, 0.0, 0, 0, 0, 0],  # Slack bus
    [2, PQ, 1.0, 0.0, 0.2, 0.1, 0, 0],
    [3, PQ, 1.0, 0.0, 0.45, 0.15, 0, 0]
])

# Line Data: [From Bus, To Bus, R (pu), X (pu), B/2 (pu)]
line_data = np.array([
    [1, 2, 0.02, 0.06, 0.03],
    [1, 3, 0.08, 0.24, 0.025],
    [2, 3, 0.06, 0.18, 0.02]
])

def build_ybus(bus_data, line_data):
    nb = bus_data.shape[0]
    ybus = np.zeros((nb, nb), dtype=complex)

    for line in line_data:
        fb, tb, r, x, bsh = int(line[0]) - 1, int(line[1]) - 1, line[2], line[3], line[4]
        z = complex(r, x)
        y = 1 / z
        ybus[fb, fb] += y + 1j*bsh
        ybus[tb, tb] += y + 1j*bsh
        ybus[fb, tb] -= y
        ybus[tb, fb] -= y

    return ybus

def power_mismatch(V, bus_data, ybus):
    nb = bus_data.shape[0]
    P = np.zeros(nb)
    Q = np.zeros(nb)
    for i in range(nb):
        Vi = V[i]
        for k in range(nb):
            Vk = V[k]
            Yik = ybus[i, k]
            angle = np.angle(Yik)
            P[i] += abs(Vi)*abs(Vk)*abs(Yik)*np.cos(np.angle(Vi)-np.angle(Vk)-angle)
            Q[i] -= abs(Vi)*abs(Vk)*abs(Yik)*np.sin(np.angle(Vi)-np.angle(Vk)-angle)

    P_spec = bus_data[:, 6] - bus_data[:, 4]  # P_gen - P_load
    Q_spec = bus_data[:, 7] - bus_data[:, 5]  # Q_gen - Q_load

    dP = P_spec - P
    dQ = Q_spec - Q

    return dP, dQ

def newton_raphson_power_flow(bus_data, line_data, tol=1e-6, max_iter=20):
    nb = bus_data.shape[0]
    ybus = build_ybus(bus_data, line_data)

    # Initialize voltage magnitudes and angles
    V_mag = bus_data[:, 2].copy()
    V_ang = np.radians(bus_data[:, 3])
    V = V_mag * np.exp(1j * V_ang)

    # Identify bus types
    pq_indices = [i for i, t in enumerate(bus_data[:, 1]) if t == PQ]
    pv_indices = [i for i, t in enumerate(bus_data[:, 1]) if t == PV]

    for iteration in range(max_iter):
        dP, dQ = power_mismatch(V, bus_data, ybus)

        # Form mismatch vector (excluding slack bus)
        mismatch_P = dP[1:]  # Skip slack bus
        mismatch_Q = dQ[pq_indices]  # Only PQ buses for Q mismatch

        mismatch = np.concatenate((mismatch_P, mismatch_Q))

        if np.max(np.abs(mismatch)) < tol:
            print(f"Converged in {iteration} iterations")
            break

        # Jacobian matrix calculation
        J = jacobian_matrix(V, ybus, bus_data, pq_indices)

        # Solve linear system for correction
        correction = np.linalg.solve(J, mismatch)

        # Update voltage angles (skip slack bus angle)
        V_ang[1:] += correction[0:nb-1]
        # Update voltage magnitudes only for PQ buses
        for idx, pq in enumerate(pq_indices):
            V_mag[pq] += correction[nb-1+idx]

        # Update voltage
        V = V_mag * np.exp(1j * V_ang)
    else:
        print("Did not converge")

    return V, ybus

def jacobian_matrix(V, ybus, bus_data, pq_indices):
    nb = bus_data.shape[0]
    npq = len(pq_indices)

    # Partial derivatives matrices
    J11 = np.zeros((nb-1, nb-1))
    J12 = np.zeros((nb-1, npq))
    J21 = np.zeros((npq, nb-1))
    J22 = np.zeros((npq, npq))

    for i in range(1, nb):
        for k in range(1, nb):
            if i == k:
                sum_term = 0
                for m in range(nb):
                    Vm = abs(V[m])
                    Yii = ybus[i, m]
                    angle_i = np.angle(V[i])
                    angle_m = np.angle(V[m])
                    Y_mag = abs(Yii)
                    theta = np.angle(Yii)
                    sum_term += Vm * Y_mag * np.sin(theta + angle_m - angle_i)
                J11[i-1, k-1] = -sum_term * abs(V[i])
            else:
                Vm = abs(V[k])
                Yii = ybus[i, k]
                angle_i = np.angle(V[i])
                angle_k = np.angle(V[k])
                Y_mag = abs(Yii)
                theta = np.angle(Yii)
                J11[i-1, k-1] = abs(V[i]) * Vm * Y_mag * np.sin(theta + angle_k - angle_i)

    for i in range(1, nb):
        for k_idx, k in enumerate(pq_indices):
            if i == k:
                sum_term = 0
                for m in range(nb):
                    Vm = abs(V[m])
                    Yii = ybus[i, m]
                    angle_i = np.angle(V[i])
                    angle_m = np.angle(V[m])
                    Y_mag = abs(Yii)
                    theta = np.angle(Yii)
                    sum_term += Vm * Y_mag * np.cos(theta + angle_m - angle_i)
                J12[i-1, k_idx] = sum_term * 2 * abs(V[i])
            else:
                Vm = abs(V[k])
                Yii = ybus[i, k]
                angle_i = np.angle(V[i])
                angle_k = np.angle(V[k])
                Y_mag = abs(Yii)
                theta = np.angle(Yii)
                J12[i-1, k_idx] = abs(V[i]) * Y_mag * np.cos(theta + angle_k - angle_i)

    for i_idx, i in enumerate(pq_indices):
        for k in range(1, nb):
            if i == k:
                sum_term = 0
                for m in range(nb):
                    Vm = abs(V[m])
                    Yii = ybus[i, m]
                    angle_i = np.angle(V[i])
                    angle_m = np.angle(V[m])
                    Y_mag = abs(Yii)
                    theta = np.angle(Yii)
                    sum_term += Vm * Y_mag * np.cos(theta + angle_m - angle_i)
                J21[i_idx, k-1] = sum_term * abs(V[i]) * -1
            else:
                Vm = abs(V[k])
                Yii = ybus[i, k]
                angle_i = np.angle(V[i])
                angle_k = np.angle(V[k])
                Y_mag = abs(Yii)
                theta = np.angle(Yii)
                J21[i_idx, k-1] = -abs(V[i]) * Vm * Y_mag * np.cos(theta + angle_k - angle_i)

    for i_idx, i in enumerate(pq_indices):
        for k_idx, k in enumerate(pq_indices):
            if i == k:
                sum_term = 0
                for m in range(nb):
                    Vm = abs(V[m])
                    Yii = ybus[i, m]
                    angle_i = np.angle(V[i])
                    angle_m = np.angle(V[m])
                    Y_mag = abs(Yii)
                    theta = np.angle(Yii)
                    sum_term += Vm * Y_mag * np.sin(theta + angle_m - angle_i)
                J22[i_idx, k_idx] = sum_term * 2 * abs(V[i])
            else:
                Vm = abs(V[k])
                Yii = ybus[i, k]
                angle_i = np.angle(V[i])
                angle_k = np.angle(V[k])
                Y_mag = abs(Yii)
                theta = np.angle(Yii)
                J22[i_idx, k_idx] = abs(V[i]) * Y_mag * np.sin(theta + angle_k - angle_i) * -1

    # Combine Jacobian blocks
    top = np.hstack((J11, J12))
    bottom = np.hstack((J21, J22))
    J = np.vstack((top, bottom))

    return J

def calculate_power_losses(V, ybus):
    nb = len(V)
    total_losses = 0
    losses_per_line = []
    for i in range(nb):
        for k in range(i+1, nb):
            Iik = (V[i] - V[k]) * ybus[i,k]
            Sik = V[i] * np.conj(Iik)
            Iki = (V[k] - V[i]) * ybus[k,i]
            Ski = V[k] * np.conj(Iki)
            loss = Sik.real + Ski.real
            losses_per_line.append(((i+1, k+1), loss))
            total_losses += loss
    return total_losses, losses_per_line

def calculate_efficiency(total_load, total_losses):
    return total_load / (total_load + total_losses)

def main():
    V, ybus = newton_raphson_power_flow(bus_data, line_data)

    # Output Bus Voltages
    print("\nBus Voltages:")
    for i, v in enumerate(V):
        print(f"Bus {i+1}: |V| = {abs(v):.4f} pu, Angle = {np.degrees(np.angle(v)):.2f} degrees")

    # Calculate power losses
    total_losses, losses_per_line = calculate_power_losses(V, ybus)
    print("\nLine Losses:")
    for (fb, tb), loss in losses_per_line:
        print(f"Line {fb}-{tb} Loss: {loss:.6f} pu")
    print(f"Total system losses: {total_losses:.6f} pu")

    # Total load
    total_load = np.sum(bus_data[:, 4])
    efficiency = calculate_efficiency(total_load, total_losses)
    print(f"\nSystem Efficiency: {efficiency*100:.2f}%")

    # Plot voltage magnitude profile
    plt.bar(range(1, len(V)+1), abs(V))
    plt.xlabel("Bus Number")
    plt.ylabel("Voltage Magnitude (pu)")
    plt.title("Bus Voltage Magnitude Profile")
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    main()

import numpy as np
import matplotlib.pyplot as plt

class LiIonBattery:
    def __init__(self, capacity_ah, nominal_voltage):
        self.capacity_ah = capacity_ah         # Battery capacity in Ah
        self.nominal_voltage = nominal_voltage # Nominal voltage in V
        self.soc = 1.0                         # Initial SOC (100%)
        self.energy_capacity_wh = capacity_ah * nominal_voltage
        self.energy_stored_wh = self.energy_capacity_wh * self.soc
        self.efficiency_charge = 0.95          # Typical charge efficiency
        self.efficiency_discharge = 0.95       # Typical discharge efficiency

    def update(self, current_a, voltage_v, dt_sec):

        power_w = voltage_v * current_a
        energy_delta_wh = power_w * dt_sec / 3600.0  # Convert W*s to Wh

        # Adjust for efficiency
        if current_a < 0:  # charging
            energy_delta_wh *= self.efficiency_charge
        else:  # discharging
            energy_delta_wh /= self.efficiency_discharge

        self.energy_stored_wh -= energy_delta_wh

        # Limit energy stored within 0 and capacity
        self.energy_stored_wh = np.clip(self.energy_stored_wh, 0, self.energy_capacity_wh)
        self.soc = self.energy_stored_wh / self.energy_capacity_wh

    def get_efficiency(self):
        # Simplified average efficiency
        return (self.efficiency_charge + self.efficiency_discharge) / 2

# Example usage

def simulate_battery():
    capacity_ah = 50        # 50 Ah battery
    nominal_voltage = 400   # 400 V battery pack
    battery = LiIonBattery(capacity_ah, nominal_voltage)

    dt = 1  # 1 second timestep
    time_total = 3600      # simulate 1 hour
    currents = np.zeros(time_total)
    voltages = np.ones(time_total) * nominal_voltage


    currents[:1800] = 10.0
    currents[1800:] = -5.0

    soc_history = []
    for t in range(time_total):
        battery.update(currents[t], voltages[t], dt)
        soc_history.append(battery.soc)

    plt.plot(np.arange(time_total)/60, soc_history)
    plt.xlabel("Time (minutes)")
    plt.ylabel("State of Charge (SOC)")
    plt.title("Li-ion Battery SOC during Charge/Discharge Cycle")
    plt.grid(True)
    plt.show()

    print(f"Final SOC after 1 hour: {battery.soc*100:.2f}%")
    print(f"Battery efficiency estimate: {battery.get_efficiency()*100:.2f}%")

if __name__ == "__main__":
    simulate_battery()